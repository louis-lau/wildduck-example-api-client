/**
 * WildDuck API
 * WildDuck API docs
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { DeleteMessagesInMailboxResponse } from '../model/deleteMessagesInMailboxResponse';
import { ForwardStoredMessageRequest } from '../model/forwardStoredMessageRequest';
import { ForwardStoredMessageResponse } from '../model/forwardStoredMessageResponse';
import { GetMessageResponse } from '../model/getMessageResponse';
import { GetMessagesResponse } from '../model/getMessagesResponse';
import { SearchMessagesResponse } from '../model/searchMessagesResponse';
import { SubmitStoredMessageRequest } from '../model/submitStoredMessageRequest';
import { SubmitStoredMessageResponse } from '../model/submitStoredMessageResponse';
import { SuccessResponse } from '../model/successResponse';
import { UpdateMessageRequest } from '../model/updateMessageRequest';
import { UpdateMessageResponse } from '../model/updateMessageResponse';
import { UploadMessageRequest } from '../model/uploadMessageRequest';
import { UploadMessageResponse } from '../model/uploadMessageResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.wildduck.email';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum MessagesApiApiKeys {
    AccessTokenAuth,
}

export class MessagesApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'AccessTokenAuth': new ApiKeyAuth('header', 'X-Access-Token'),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: MessagesApiApiKeys, value: string) {
        (this.authentications as any)[MessagesApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * 
     * @summary Delete a Message
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message Message ID
     */
    public async deleteMessage (user: string, mailbox: string, message: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SuccessResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling deleteMessage.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling deleteMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SuccessResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SuccessResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Delete all Messages from a Mailbox
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param async Schedule deletion task
     */
    public async deleteMessagesInMailbox (user: string, mailbox: string, async?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteMessagesInMailboxResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling deleteMessagesInMailbox.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling deleteMessagesInMailbox.');
        }

        if (async !== undefined) {
            localVarQueryParameters['async'] = ObjectSerializer.serialize(async, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteMessagesInMailboxResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "DeleteMessagesInMailboxResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     * @summary Forward stored Message
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message Message ID
     * @param forwardStoredMessageRequest This method allows either to re-forward a message to an original forward target or forward it to some other address. This is useful if a user had forwarding turned on but the message was not delivered so you can try again. Forwarding does not modify the original message.
     */
    public async forwardStoredMessage (user: string, mailbox: string, message: number, forwardStoredMessageRequest: ForwardStoredMessageRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ForwardStoredMessageResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}/forward'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling forwardStoredMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling forwardStoredMessage.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling forwardStoredMessage.');
        }

        // verify required parameter 'forwardStoredMessageRequest' is not null or undefined
        if (forwardStoredMessageRequest === null || forwardStoredMessageRequest === undefined) {
            throw new Error('Required parameter forwardStoredMessageRequest was null or undefined when calling forwardStoredMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(forwardStoredMessageRequest, "ForwardStoredMessageRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ForwardStoredMessageResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "ForwardStoredMessageResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Request Message information
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message Message ID
     * @param markAsSeen If true then marks message as seen
     */
    public async getMessage (user: string, mailbox: string, message: number, markAsSeen?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetMessageResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling getMessage.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling getMessage.');
        }

        if (markAsSeen !== undefined) {
            localVarQueryParameters['markAsSeen'] = ObjectSerializer.serialize(markAsSeen, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetMessageResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetMessageResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method returns attachment file contents in binary form
     * @summary Download Attachment
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message ID of the Message
     * @param attachment ID of the Attachment
     */
    public async getMessageAttachment (user: string, mailbox: string, message: number, attachment: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}/attachments/{attachment}'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)))
            .replace('{' + 'attachment' + '}', encodeURIComponent(String(attachment)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/octet-stream'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMessageAttachment.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling getMessageAttachment.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling getMessageAttachment.');
        }

        // verify required parameter 'attachment' is not null or undefined
        if (attachment === null || attachment === undefined) {
            throw new Error('Required parameter attachment was null or undefined when calling getMessageAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "Buffer");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method returns the full RFC822 formatted source of the stored message
     * @summary Get Message source
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message ID of the Message
     */
    public async getMessageSource (user: string, mailbox: string, message: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: object;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}/message.eml'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['text/plain'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMessageSource.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling getMessageSource.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling getMessageSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "object");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary List messages in a Mailbox
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param unseen If true, then returns only unseen messages
     * @param metaData If true, then includes metaData in the response
     * @param limit How many records to return
     * @param page Current page number. Informational only, page numbers start from 1
     * @param order Ordering of the records by insert date
     * @param next Cursor value for next page, retrieved from nextCursor response value
     * @param previous Cursor value for previous page, retrieved from previousCursor response value
     */
    public async getMessages (user: string, mailbox: string, unseen?: number, metaData?: boolean, limit?: number, page?: number, order?: number, next?: number, previous?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetMessagesResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMessages.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling getMessages.');
        }

        if (unseen !== undefined) {
            localVarQueryParameters['unseen'] = ObjectSerializer.serialize(unseen, "number");
        }

        if (metaData !== undefined) {
            localVarQueryParameters['metaData'] = ObjectSerializer.serialize(metaData, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "number");
        }

        if (next !== undefined) {
            localVarQueryParameters['next'] = ObjectSerializer.serialize(next, "number");
        }

        if (previous !== undefined) {
            localVarQueryParameters['previous'] = ObjectSerializer.serialize(previous, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetMessagesResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "GetMessagesResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * 
     * @summary Search for messages
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param thread Thread ID
     * @param query Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param datestart Datestring for the earliest message storing time
     * @param dateend Datestring for the latest message storing time
     * @param from Partial match for the From: header line
     * @param to Partial match for the To: and Cc: header lines
     * @param subject Partial match for the Subject: header line
     * @param attachments If true, then matches only messages with attachments
     * @param flagged If true, then matches only messages with \\Flagged flags
     * @param unseen If true, then matches only messages without \\Seen flags
     * @param searchable If true, then matches messages not in Junk or Trash
     * @param orQuery Search string, uses MongoDB fulltext index. Covers data from mesage body and also common headers like from, to, subject etc.
     * @param orFrom Partial match for the From: header line
     * @param orTo Partial match for the To: and Cc: header lines
     * @param orSubject Partial match for the Subject: header line
     * @param limit How many records to return
     * @param page Current page number. Informational only, page numbers start from 1
     * @param next Cursor value for next page, retrieved from nextCursor response value
     * @param previous Cursor value for previous page, retrieved from previousCursor response value
     */
    public async searchMessages (user: string, mailbox?: string, thread?: string, query?: string, datestart?: Date, dateend?: Date, from?: string, to?: string, subject?: string, attachments?: boolean, flagged?: boolean, unseen?: boolean, searchable?: boolean, orQuery?: string, orFrom?: string, orTo?: string, orSubject?: string, limit?: number, page?: number, next?: number, previous?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchMessagesResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/search'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling searchMessages.');
        }

        if (mailbox !== undefined) {
            localVarQueryParameters['mailbox'] = ObjectSerializer.serialize(mailbox, "string");
        }

        if (thread !== undefined) {
            localVarQueryParameters['thread'] = ObjectSerializer.serialize(thread, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        if (datestart !== undefined) {
            localVarQueryParameters['datestart'] = ObjectSerializer.serialize(datestart, "Date");
        }

        if (dateend !== undefined) {
            localVarQueryParameters['dateend'] = ObjectSerializer.serialize(dateend, "Date");
        }

        if (from !== undefined) {
            localVarQueryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (to !== undefined) {
            localVarQueryParameters['to'] = ObjectSerializer.serialize(to, "string");
        }

        if (subject !== undefined) {
            localVarQueryParameters['subject'] = ObjectSerializer.serialize(subject, "string");
        }

        if (attachments !== undefined) {
            localVarQueryParameters['attachments'] = ObjectSerializer.serialize(attachments, "boolean");
        }

        if (flagged !== undefined) {
            localVarQueryParameters['flagged'] = ObjectSerializer.serialize(flagged, "boolean");
        }

        if (unseen !== undefined) {
            localVarQueryParameters['unseen'] = ObjectSerializer.serialize(unseen, "boolean");
        }

        if (searchable !== undefined) {
            localVarQueryParameters['searchable'] = ObjectSerializer.serialize(searchable, "boolean");
        }

        if (orQuery !== undefined) {
            localVarQueryParameters['or.query'] = ObjectSerializer.serialize(orQuery, "string");
        }

        if (orFrom !== undefined) {
            localVarQueryParameters['or.from'] = ObjectSerializer.serialize(orFrom, "string");
        }

        if (orTo !== undefined) {
            localVarQueryParameters['or.to'] = ObjectSerializer.serialize(orTo, "string");
        }

        if (orSubject !== undefined) {
            localVarQueryParameters['or.subject'] = ObjectSerializer.serialize(orSubject, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (next !== undefined) {
            localVarQueryParameters['next'] = ObjectSerializer.serialize(next, "number");
        }

        if (previous !== undefined) {
            localVarQueryParameters['previous'] = ObjectSerializer.serialize(previous, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchMessagesResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SearchMessagesResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     * @summary Submit Draft for delivery
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param message Message ID
     * @param submitStoredMessageRequest This method allows to submit a draft message for delivery. Draft is moved to Sent mail folder.
     */
    public async submitStoredMessage (user: string, mailbox: string, message: number, submitStoredMessageRequest: SubmitStoredMessageRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubmitStoredMessageResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages/{message}/submit'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)))
            .replace('{' + 'message' + '}', encodeURIComponent(String(message)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling submitStoredMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling submitStoredMessage.');
        }

        // verify required parameter 'message' is not null or undefined
        if (message === null || message === undefined) {
            throw new Error('Required parameter message was null or undefined when calling submitStoredMessage.');
        }

        // verify required parameter 'submitStoredMessageRequest' is not null or undefined
        if (submitStoredMessageRequest === null || submitStoredMessageRequest === undefined) {
            throw new Error('Required parameter submitStoredMessageRequest was null or undefined when calling submitStoredMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(submitStoredMessageRequest, "SubmitStoredMessageRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubmitStoredMessageResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "SubmitStoredMessageResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method updates message flags and also allows to move messages to a different mailbox
     * @summary Update Message information
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param updateMessageRequest 
     */
    public async updateMessage (user: string, mailbox: string, updateMessageRequest: UpdateMessageRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UpdateMessageResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling updateMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling updateMessage.');
        }

        // verify required parameter 'updateMessageRequest' is not null or undefined
        if (updateMessageRequest === null || updateMessageRequest === undefined) {
            throw new Error('Required parameter updateMessageRequest was null or undefined when calling updateMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateMessageRequest, "UpdateMessageRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UpdateMessageResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UpdateMessageResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This method allows to upload either an RFC822 formatted message or a message structure to a mailbox. Raw message is stored unmodified, no headers are added or removed. If you want to generate the uploaded message from strucutred data fields, then do not use the raw property.
     * @summary Upload Message
     * @param user ID of the User
     * @param mailbox ID of the Mailbox
     * @param uploadMessageRequest 
     */
    public async uploadMessage (user: string, mailbox: string, uploadMessageRequest: UploadMessageRequest, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UploadMessageResponse;  }> {
        const localVarPath = this.basePath + '/users/{user}/mailboxes/{mailbox}/messages'
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)))
            .replace('{' + 'mailbox' + '}', encodeURIComponent(String(mailbox)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling uploadMessage.');
        }

        // verify required parameter 'mailbox' is not null or undefined
        if (mailbox === null || mailbox === undefined) {
            throw new Error('Required parameter mailbox was null or undefined when calling uploadMessage.');
        }

        // verify required parameter 'uploadMessageRequest' is not null or undefined
        if (uploadMessageRequest === null || uploadMessageRequest === undefined) {
            throw new Error('Required parameter uploadMessageRequest was null or undefined when calling uploadMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(uploadMessageRequest, "UploadMessageRequest")
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.AccessTokenAuth.apiKey) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.AccessTokenAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UploadMessageResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "UploadMessageResponse");
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
